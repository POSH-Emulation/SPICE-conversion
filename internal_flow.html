
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Flow &#8212; degem  documentation</title>
    <link rel="stylesheet" href="alabaster.css" type="text/css" />
    <link rel="stylesheet" href="pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="documentation_options.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="underscore.js"></script>
    <script type="text/javascript" src="doctools.js"></script>
    <script type="text/javascript" src="language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Algorithms" href="algorithms.html" />
    <link rel="prev" title="TOP" href="circuits:Brown:TempSense:TOP.html" />
   
  <link rel="stylesheet" href="custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="flow">
<h1>Flow<a class="headerlink" href="#flow" title="Permalink to this headline"></a></h1>
<p>DEGEM’s main flow is automatic, linear and design-independent.
It is comprised of 3 main stage:</p>
<ol class="arabic simple">
<li><p>Circuit Recognition</p></li>
<li><p>Characterization</p></li>
<li><p>Model Generation</p></li>
</ol>
<p>The tool relies on two other logistical flows, which provide cached libraries and reference data that is infrequently updated.</p>
<div class="section" id="circuit-recognition">
<h2>Circuit Recognition<a class="headerlink" href="#circuit-recognition" title="Permalink to this headline"></a></h2>
<p>Circuit recognition is the stage where the tool analyzes the structure of the circuit and creates an abstract representation of the internal data flow.
The stage breaks down to the following sub-stages:</p>
<ol class="arabic simple">
<li><p>Flattening - removing all hierarchies from the circuit</p></li>
<li><p>Conditioning - a series of standard operations that removes common obstacles that distract downstream algorithms.</p></li>
<li><p>Grouping - grouping components into cells.</p></li>
<li><p>Classifying - applying classification rules to each cell, to determine if it is digital or analog and trivial identification of interface.</p></li>
<li><p>Extracting - applying Boolean extraction methods for each grouped digital cell.</p></li>
<li><p>Matching - finding a corresponding library cell for each grouped analog cell.</p></li>
<li><p>Merging - constructing a data flow graph.</p></li>
</ol>
<div class="section" id="flattening">
<h3>Flattening<a class="headerlink" href="#flattening" title="Permalink to this headline"></a></h3>
<p>While default at the moment, this stage can be skipped or applied selectively to sub-circuits.
Flattening the circuit achieves the following goals:</p>
<ul class="simple">
<li><p>It removes structures that could obfuscate topology, such as loose components mixed together with sub-circuit instances.</p></li>
<li><p>It simplifies Boolean extraction of digital cells.</p></li>
<li><p>It removes component encapsulation, as provided by foundries.</p></li>
</ul>
<p>However, a flattened circuit introduces some challenges too:</p>
<ul class="simple">
<li><p>Run time is multiplied by repeating topology analysis on repetitively instanciated sub-circuits.</p></li>
<li><p>Some topological information that is expressed by the original hierarchy gets lost.</p></li>
<li><p>Analyzed and annotated circuit is large and can be hard to read by user.</p></li>
</ul>
</div>
<div class="section" id="conditioning">
<h3>Conditioning<a class="headerlink" href="#conditioning" title="Permalink to this headline"></a></h3>
<p>In preparation for topology analysis, the tool must identify and deal with some structures that are corner-cases or complicate the algorithms:</p>
<ul class="simple">
<li><p>Parallel and serial components - while electrically significant, there is no topological meaning to having two FET channels (for instance) connected in series and sharing the same gate. Merging transistors and components to “super transistors” and “super components” respectively simplifies cell-level recognition later on.</p></li>
<li><p>Darlington transistor (not implemented yet) - a similar merger in case of a BJT super transistor.</p></li>
<li><p>Dummies - Some transistors are instanciated in an always-off, capacitor load or layout artifacts. These instances can be ignored for topological analysis purposes.</p></li>
<li><p>Switches - P and N channels that connect source to source and drain to drain are quickly identified and grouped as switches.</p></li>
</ul>
</div>
<div class="section" id="grouping">
<h3>Grouping<a class="headerlink" href="#grouping" title="Permalink to this headline"></a></h3>
<p>The grouping algorithm finds clusters of transistors and connecting components that share current. Grouped transistors are connected by channels: sources and drains (for FET) or collectors and emitters (for BJT). A gate connection is ignored.
There are two optional strategies to grouping together transistors into cells:</p>
<ul class="simple">
<li><dl class="simple">
<dt>“King of the Hill” - uses the well-ordering principle to find local maxima in each channel-connected block (CCB):</dt><dd><ul>
<li><p>Give each transistor a unique strength number (1,2,3…)</p></li>
<li><p>Around each net, look for the strongest transistor that connects to it by channel. Update the other transistors with the strongest’s number.</p></li>
<li><p>Repeat previous step, until no further updates</p></li>
<li><p>Use the surviving numbers to group cluster of transistors into cells</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>“Picky Eater” - constructs clusters bottom-up, while keeping information about their drivers:</dt><dd><ul>
<li><p>Mark each transistor with the name of its driving net and type of channel (e.g. in0:P, a[3]:N).</p></li>
<li><p>For each net, merge pairs of channel-connected clusters only if they don’t share a driver marking.</p></li>
<li><p>A merged cluster inherits all the marking from the original clusters.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>The first algorithm is the faster one. However, it is not useful in cases cells drive common output, because that connection shortens channels between the cells.
The grouping stage tries “King of the Hill” first and uses a size threshold to detect cells that should be more selectively grouped, using the “Picky Eater” approach.</p>
</div>
<div class="section" id="classifying">
<h3>Classifying<a class="headerlink" href="#classifying" title="Permalink to this headline"></a></h3>
<p>Initially, cells are marked with interface directionality, according to the following rules:</p>
<ul class="simple">
<li><p>Inputs - pins that connect to transistor gates only, either directly or via resistors, are considered inputs.</p></li>
<li><p>Power nets - are identified by external connections. An input cannot be marked as “power”, even if it is degenerated by direct connection to a rail.</p></li>
<li><p>Outputs - any pin that is not power or input is considered output. Bi-directional pins are not automatically identified.</p></li>
</ul>
<p>The classification stage then uses simple, intuitive rules to determine which category and corresponding analysis should be applied to each cell:</p>
<ul class="simple">
<li><p>Digital - expect equal P and N count, uniform channel lengths and no passive components, such as resistors or deiodes. Apply Boolean extraction to determine function.</p></li>
<li><dl class="simple">
<dt>Analog - not digital. Apply topology matching with library, unless the cell conforms to one of the trivial categories:</dt><dd><ul>
<li><p>Switches - previously identified and now left alone.</p></li>
<li><p>Bias - cells that do not have any inputs.</p></li>
<li><p>Passive - cells that do not have any outputs.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>All classification rules can be suspended per user configuration, to fit special design styles.
For instance, in CMOS cells there could be parallel N branches, which violated the equal P/N count rule.
Turning that rule off allows the tool to still classify those cells as digital, based on the other symptoms.</p>
</div>
<div class="section" id="extracting">
<h3>Extracting<a class="headerlink" href="#extracting" title="Permalink to this headline"></a></h3>
<p>Dual functions separate the cases for each logic level on a net.
The possible levels are:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(X_{H}\)</span> - There’s an open path from X to VDD</p></li>
<li><p><span class="math notranslate nohighlight">\(X_{L}\)</span> - There’s an open path from X to VSS</p></li>
<li><p><span class="math notranslate nohighlight">\(X_{1}\)</span> - X level is exclusively high</p></li>
<li><p><span class="math notranslate nohighlight">\(X_{0}\)</span> - X level is exclusively low</p></li>
<li><p><span class="math notranslate nohighlight">\(X_{Z}\)</span> - X is undriven</p></li>
<li><p><span class="math notranslate nohighlight">\(X_{X}\)</span> - contention on X</p></li>
</ol>
<p>Each net gets its driving tree analyzed and the <span class="math notranslate nohighlight">\(X_{H}\)</span> and <span class="math notranslate nohighlight">\(X_{L}\)</span> equations are generated.
Once those equations are generated, the rest of them can be derived, using the following transformations:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(X_{1}=X_{H} * \overline{ X_{L} }\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(X_{0}=\overline{ X_{H} } * X_{L}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(X_{Z}=\overline{ X_{H} } * \overline{ X_{L} }\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(X_{X}=X_{H} * X_{L}\)</span></p></li>
</ol>
<p>deeper extraction uses the above equations and traces the dependences on nodes as close as possible to the inputs by replaceing intermediate nodes with their <span class="math notranslate nohighlight">\(X_{1}\)</span> equations.
This stage can find nodes that depend on themselves, which indicate data-retention or latch nodes.
The resulting stack of equations has outputs and latch nodes on the left-hand side and inputs and latch nodes on the right-hand side.</p>
</div>
<div class="section" id="matching">
<h3>Matching<a class="headerlink" href="#matching" title="Permalink to this headline"></a></h3>
<p>An analog cell that was not ruled trivial in the classification stage is identified by matching it to a cell from the library.</p>
<p>Canonical Graph Labeling is the basis for cell matching.
The method creates a canonical hash key for a cell and uses it to narrow down the search for a matching library cell.
We prototyped the following labeling method:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Label each net:</dt><dd><ul>
<li><p>Count its gate, channel and port connections (N/P for gates, n/p for channels, b/B for N/P bodies)</p></li>
<li><p>List each category with a letter and count in lexicographical order
(e.g. P2n1 = 2 PMOS gates + 1 NMOS channel connections)</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>List all net labels in lexicographical order, separated by colons.</p></li>
<li><p>Group identical net labels with a preceding count (e.g. 3P2n1:p2)</p></li>
</ul>
<p>Example: An N-type diff-pair is labeled B2p2:2N:P2np:b3n:n2:np</p>
<p>Actual labels are generated with distinction between components that connect directly to power rails, ones that are 1 degree of separation from rails, 2 degrees and so on.
The label is also coded in base64, to conserve on label length and decoding time.</p>
<p>One of the logisitical flow generates canonical labels for each library cell and trains the Machine-Learning (ML) algorithms for secondary, ternary etc. matching.
While calculating the global label, per-net labels are also kept, to simplify low-level matching of design cell nets to library cell ones.</p>
<p>The matching stage uses cascading algorithms approach. Each matching algorithm is statistically expected to match the cell, but with some probability to miss and have the matching passed to downstream algorithms.
The matching algorith order is as following:</p>
<ol class="arabic simple">
<li><p>Direct match - the design cell label matches a library label.</p></li>
<li><p>One-extra match - match to pre-trained label that was calculated with commonly placed transistors between the output and a power rail.</p></li>
<li><p>Quarantined input-driven transistors - a match after a design input and all connecting transistors are removed.</p></li>
<li><p>Cluster classification - finds the closest topology-family cluster. While this is not considered a final match, it serves to accelerate library updates.</p></li>
</ol>
<p>Following cell matching, the interface nets are identified and marked according to the naming convention of the library cell’s ones.
This sets up the initial dependence arcs, which are the analog-circuit equivalent to timing arcs in digital circuits.
After the initial arcs are set by the recognised cells, nodes that connect to cells via loose components are also marked by arcs, until all relevant nodes are on arcs.</p>
</div>
<div class="section" id="merging">
<h3>Merging<a class="headerlink" href="#merging" title="Permalink to this headline"></a></h3>
<p>Dependence arcs are extended to the rest of the design and merged to form full dependence paths.
Unlike switching (timing) paths of Static Timing Analysis (STA), analog dependence paths are not classified in the edge to edge convention (e.g. rise-&gt;rise), but according to the following types:</p>
<ul class="simple">
<li><p>analog - quasi-linear, time invariant (LTI) dependence</p></li>
<li><p>digital - enable or mode input. A different behavior is expected for hi and lo levels.</p></li>
<li><p>control - a slow-moving signal that can have any random value and has an influence on the ndoe’s behavior with respect to other nodes.</p></li>
<li><p>bias - a static node that has no behavioral significance.</p></li>
</ul>
<p>Merging nets relies on rules that can be summarized in the following table:</p>
<p>Before: <code class="docutils literal notranslate"><span class="pre">Source</span> <span class="pre">Node</span></code> <strong>Column Type</strong> <code class="docutils literal notranslate"><span class="pre">Intermediate</span> <span class="pre">Node</span></code> <strong>Row Type</strong> <code class="docutils literal notranslate"><span class="pre">Target</span> <span class="pre">Node</span></code></p>
<p>After:                      <code class="docutils literal notranslate"><span class="pre">Source</span> <span class="pre">Node</span></code> <strong>Rubric Type</strong> <code class="docutils literal notranslate"><span class="pre">Target</span> <span class="pre">Node</span></code></p>
<table class="docutils align-center">
<colgroup>
<col style="width: 29%" />
<col style="width: 21%" />
<col style="width: 19%" />
<col style="width: 19%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Merge</p></th>
<th class="head"><p>Analog</p></th>
<th class="head"><p>Digital</p></th>
<th class="head"><p>Control</p></th>
<th class="head"><p>Bias</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Analog</strong></p></td>
<td><p>Analog</p></td>
<td><p>Digital</p></td>
<td><p>Control</p></td>
<td><p>Bias</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Digital</strong></p></td>
<td><p>Analog</p></td>
<td><p>Digital</p></td>
<td><p>Control</p></td>
<td><p>Bias</p></td>
</tr>
<tr class="row-even"><td><p><strong>Control</strong></p></td>
<td><p>Control</p></td>
<td><p>Digital</p></td>
<td><p>Control</p></td>
<td><p>Bias</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Bias</strong></p></td>
<td><p>Control</p></td>
<td><p>Digital</p></td>
<td><p>Control</p></td>
<td><p>Bias</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="characterization">
<h2>Characterization<a class="headerlink" href="#characterization" title="Permalink to this headline"></a></h2>
<p>Once the design’s data flow is recognized, the model’s specific behavior and parameters are evaluated by simulating specific scenarios and post-processing the resulting vectors.
This stage has three parts:</p>
<ol class="arabic simple">
<li><p>Harness and input vector compilation</p></li>
<li><p>SPICE simulation</p></li>
<li><p>Post-processing</p></li>
</ol>
<div class="section" id="harness-compilation">
<h3>Harness Compilation<a class="headerlink" href="#harness-compilation" title="Permalink to this headline"></a></h3>
</div>
</div>
<div class="section" id="model-generation">
<h2>Model Generation<a class="headerlink" href="#model-generation" title="Permalink to this headline"></a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">degem</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whats_degem.html">What is DEGEM?</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual.html">Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="API.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="library.html">Topology library</a></li>
<li class="toctree-l1"><a class="reference internal" href="test_regression.html">Test Bench</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Flow</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#circuit-recognition">Circuit Recognition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#characterization">Characterization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#model-generation">Model Generation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">Algorithms</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="circuits:Brown:TempSense:TOP.html" title="previous chapter">TOP</a></li>
      <li>Next: <a href="algorithms.html" title="next chapter">Algorithms</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Yishai Statter.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.0.0+</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/internal_flow.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
